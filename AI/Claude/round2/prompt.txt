"""
Frogger Game Implementation
==========================

เกม Frogger คลาสสิกที่ผู้เล่นควบคุมกบเพื่อข้ามถนนและแม่น้ำเพื่อกลับบ้าน

โครงสร้างเกม:
- หน้าจอขนาด 800x600 pixels
- โซนถนน (ครึ่งล่าง): มีรถยนต์วิ่งในทิศทางต่างๆ
- โซนแม่น้ำ (ครึ่งบน): มีขอนไม้และเต่าลอยน้ำ
- บ้านกบ 5 ช่องที่ด้านบนสุด
- ระบบชีวิต 3 ชีวิต
- ระบบเวลาจำกัดแต่ละรอบ
"""

import pygame
import random
import time
from typing import List, Tuple, Optional
from enum import Enum

# การตั้งค่าหลักของเกม
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
GRID_SIZE = 40
FPS = 60

# สีที่ใช้ในเกม
class Colors:
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    GREEN = (0, 255, 0)
    BLUE = (0, 0, 255)
    RED = (255, 0, 0)
    YELLOW = (255, 255, 0)
    BROWN = (139, 69, 19)
    GRAY = (128, 128, 128)
    DARK_GREEN = (0, 128, 0)
    LIGHT_BLUE = (173, 216, 230)

class Direction(Enum):
    """ทิศทางการเคลื่อนที่"""
    UP = (0, -1)
    DOWN = (0, 1)
    LEFT = (-1, 0)
    RIGHT = (1, 0)

class GameObject:
    """คลาสพื้นฐานสำหรับวัตถุในเกม"""
    
    def __init__(self, x: int, y: int, width: int, height: int, color: Tuple[int, int, int]):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.rect = pygame.Rect(x, y, width, height)
    
    def update_rect(self):
        """อัปเดตตำแหน่ง rect"""
        self.rect.x = self.x
        self.rect.y = self.y
    
    def draw(self, screen: pygame.Surface):
        """วาดวัตถุบนหน้าจอ"""
        pygame.draw.rect(screen, self.color, self.rect)
    
    def get_center(self) -> Tuple[int, int]:
        """ได้ตำแหน่งจุดกึ่งกลาง"""
        return self.x + self.width // 2, self.y + self.height // 2

class Frog(GameObject):
    """คลาสกบผู้เล่น"""
    
    def __init__(self, start_x: int, start_y: int):
        super().__init__(start_x, start_y, GRID_SIZE - 4, GRID_SIZE - 4, Colors.GREEN)
        self.start_x = start_x
        self.start_y = start_y
        self.on_log = False
        self.log_speed = 0
    
    def move(self, direction: Direction) -> bool:
        """เคลื่อนที่กบตามทิศทางที่กำหนด"""
        dx, dy = direction.value
        new_x = self.x + dx * GRID_SIZE
        new_y = self.y + dy * GRID_SIZE
        
        # ตรวจสอบขอบเขตหน้าจอ
        if 0 <= new_x <= SCREEN_WIDTH - self.width and 0 <= new_y <= SCREEN_HEIGHT - self.height:
            self.x = new_x
            self.y = new_y
            self.update_rect()
            return True
        return False
    
    def reset_position(self):
        """รีเซ็ตตำแหน่งกบกลับไปจุดเริ่มต้น"""
        self.x = self.start_x
        self.y = self.start_y
        self.on_log = False
        self.log_speed = 0
        self.update_rect()
    
    def update_on_log(self, speed: int):
        """อัปเดตตำแหน่งเมื่ออยู่บนขอนไม้"""
        if self.on_log:
            self.x += speed
            # ตรวจสอบไม่ให้ออกนอกขอบจอ
            if self.x < 0:
                self.x = 0
            elif self.x > SCREEN_WIDTH - self.width:
                self.x = SCREEN_WIDTH - self.width
            self.update_rect()

class Vehicle(GameObject):
    """คลาสยานพาหนะในโซนถนน"""
    
    def __init__(self, x: int, y: int, speed: int, color: Tuple[int, int, int]):
        super().__init__(x, y, GRID_SIZE + 10, GRID_SIZE - 10, color)
        self.speed = speed
    
    def update(self):
        """อัปเดตตำแหน่งยานพาหนะ"""
        self.x += self.speed
        
        # หากออกจากหน้าจอให้วนกลับมาอีกฝั่ง
        if self.speed > 0 and self.x > SCREEN_WIDTH:
            self.x = -self.width
        elif self.speed < 0 and self.x < -self.width:
            self.x = SCREEN_WIDTH
        
        self.update_rect()

class Log(GameObject):
    """คลาสขอนไม้ในโซนแม่น้ำ"""
    
    def __init__(self, x: int, y: int, speed: int, length: int = 2):
        width = length * GRID_SIZE
        super().__init__(x, y, width, GRID_SIZE - 10, Colors.BROWN)
        self.speed = speed
        self.length = length
    
    def update(self):
        """อัปเดตตำแหน่งขอนไม้"""
        self.x += self.speed
        
        # หากออกจากหน้าจอให้วนกลับมาอีกฝั่ง
        if self.speed > 0 and self.x > SCREEN_WIDTH:
            self.x = -self.width
        elif self.speed < 0 and self.x < -self.width:
            self.x = SCREEN_WIDTH
        
        self.update_rect()

class Turtle(GameObject):
    """คลาสเต่าในโซนแม่น้ำ"""
    
    def __init__(self, x: int, y: int, speed: int):
        super().__init__(x, y, GRID_SIZE, GRID_SIZE - 10, Colors.DARK_GREEN)
        self.speed = speed
        self.dive_timer = random.randint(180, 300)  # 3-5 วินาที ที่ 60 FPS
        self.is_diving = False
        self.dive_duration = 60  # 1 วินาที
    
    def update(self):
        """อัปเดตตำแหน่งและสถานะการดำน้ำของเต่า"""
        self.x += self.speed
        
        # หากออกจากหน้าจอให้วนกลับมาอีกฝั่ง
        if self.speed > 0 and self.x > SCREEN_WIDTH:
            self.x = -self.width
        elif self.speed < 0 and self.x < -self.width:
            self.x = SCREEN_WIDTH
        
        # จัดการการดำน้ำ
        self.dive_timer -= 1
        if self.dive_timer <= 0:
            if not self.is_diving:
                self.is_diving = True
                self.dive_timer = self.dive_duration
            else:
                self.is_diving = False
                self.dive_timer = random.randint(180, 300)
        
        self.update_rect()
    
    def draw(self, screen: pygame.Surface):
        """วาดเต่า (ไม่วาดถ้ากำลังดำน้ำ)"""
        if not self.is_diving:
            super().draw(screen)

class Home(GameObject):
    """คลาสบ้านกบ"""
    
    def __init__(self, x: int, y: int):
        super().__init__(x, y, GRID_SIZE, GRID_SIZE, Colors.YELLOW)
        self.occupied = False
    
    def draw(self, screen: pygame.Surface):
        """วาดบ้าน"""
        color = Colors.GREEN if self.occupied else Colors.YELLOW
        pygame.draw.rect(screen, color, self.rect)
        pygame.draw.rect(screen, Colors.BLACK, self.rect, 2)

class GameState:
    """สถานะของเกม"""
    
    def __init__(self):
        self.lives = 3
        self.score = 0
        self.level = 1
        self.time_left = 30.0  # วินาที
        self.game_over = False
        self.level_complete = False
        self.homes_filled = 0

class FroggerGame:
    """คลาสหลักของเกม Frogger"""
    
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Frogger Game")
        self.clock = pygame.time.Clock()
        
        # ตัวแปรสถานะเกม
        self.game_state = GameState()
        self.running = True
        
        # สร้างวัตถุในเกม
        self._init_game_objects()
        
        # ฟอนต์สำหรับแสดงข้อความ
        self.font = pygame.font.Font(None, 36)
        self.small_font = pygame.font.Font(None, 24)
    
    def _init_game_objects(self):
        """สร้างวัตถุต่างๆ ในเกม"""
        # สร้างกบ
        frog_start_x = SCREEN_WIDTH // 2 - GRID_SIZE // 2
        frog_start_y = SCREEN_HEIGHT - GRID_SIZE - 10
        self.frog = Frog(frog_start_x, frog_start_y)
        
        # สร้างยานพาหนะ
        self.vehicles = []
        self._create_vehicles()
        
        # สร้างขอนไม้และเต่า
        self.logs = []
        self.turtles = []
        self._create_river_objects()
        
        # สร้างบ้าน
        self.homes = []
        self._create_homes()
    
    def _create_vehicles(self):
        """สร้างยานพาหนะในโซนถนน"""
        road_rows = [
            (SCREEN_HEIGHT - 120, 2, Colors.RED),    # แถวล่างสุด
            (SCREEN_HEIGHT - 160, -3, Colors.BLUE),  # แถวที่ 2
            (SCREEN_HEIGHT - 200, 1, Colors.YELLOW), # แถวที่ 3
            (SCREEN_HEIGHT - 240, -2, Colors.GRAY),  # แถวที่ 4
        ]
        
        for y, speed, color in road_rows:
            # สร้างรถ 3-5 คันต่อแถว
            num_vehicles = random.randint(3, 5)
            spacing = SCREEN_WIDTH // num_vehicles
            
            for i in range(num_vehicles):
                if speed > 0:
                    x = i * spacing - random.randint(0, spacing)
                else:
                    x = SCREEN_WIDTH - i * spacing + random.randint(0, spacing)
                
                vehicle = Vehicle(x, y, speed, color)
                self.vehicles.append(vehicle)
    
    def _create_river_objects(self):
        """สร้างขอนไม้และเต่าในโซนแม่น้ำ"""
        river_rows = [
            (180, 1, 'log'),     # แถวบนสุด
            (140, -2, 'turtle'), # แถวที่ 2
            (100, 1, 'log'),     # แถวที่ 3
            (60, -1, 'turtle'),  # แถวล่างสุด
        ]
        
        for y, speed, obj_type in river_rows:
            if obj_type == 'log':
                # สร้างขอนไม้ 2-3 ท่อนต่อแถว
                num_logs = random.randint(2, 3)
                spacing = SCREEN_WIDTH // num_logs
                
                for i in range(num_logs):
                    if speed > 0:
                        x = i * spacing * 2 - random.randint(0, spacing)
                    else:
                        x = SCREEN_WIDTH - i * spacing * 2 + random.randint(0, spacing)
                    
                    log_length = random.randint(2, 4)
                    log = Log(x, y, speed, log_length)
                    self.logs.append(log)
            
            elif obj_type == 'turtle':
                # สร้างเต่า 3-4 ตัวต่อแถว
                num_turtles = random.randint(3, 4)
                spacing = SCREEN_WIDTH // num_turtles
                
                for i in range(num_turtles):
                    if speed > 0:
                        x = i * spacing * 2 - random.randint(0, spacing)
                    else:
                        x = SCREEN_WIDTH - i * spacing * 2 + random.randint(0, spacing)
                    
                    turtle = Turtle(x, y, speed)
                    self.turtles.append(turtle)
    
    def _create_homes(self):
        """สร้างบ้านกบ 5 ช่อง"""
        home_width = SCREEN_WIDTH // 6
        start_x = home_width // 2
        
        for i in range(5):
            x = start_x + i * home_width
            y = 10
            home = Home(x, y)
            self.homes.append(home)
    
    def handle_input(self) -> bool:
        """จัดการ input จากผู้เล่น"""
        keys_pressed = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            
            elif event.type == pygame.KEYDOWN:
                keys_pressed.append(event.key)
                
                if not self.game_state.game_over and not self.game_state.level_complete:
                    if event.key == pygame.K_UP:
                        self.frog.move(Direction.UP)
                    elif event.key == pygame.K_DOWN:
                        self.frog.move(Direction.DOWN)
                    elif event.key == pygame.K_LEFT:
                        self.frog.move(Direction.LEFT)
                    elif event.key == pygame.K_RIGHT:
                        self.frog.move(Direction.RIGHT)
                
                elif self.game_state.game_over or self.game_state.level_complete:
                    if event.key == pygame.K_r:
                        self.restart_game()
        
        # Return the keys for testing purposes
        return keys_pressed if keys_pressed else True
    
    def update_game_logic(self):
        """อัปเดตตรรกะหลักของเกม"""
        if self.game_state.game_over or self.game_state.level_complete:
            return
        
        # อัปเดตเวลา
        self.game_state.time_left -= 1/60  # ลดลง 1/60 วินาทีต่อเฟรม
        
        if self.game_state.time_left <= 0:
            self._lose_life()
            return
        
        # อัปเดตยานพาหนะ
        for vehicle in self.vehicles:
            vehicle.update()
        
        # อัปเดตขอนไม้และเต่า
        for log in self.logs:
            log.update()
        
        for turtle in self.turtles:
            turtle.update()
        
        # ตรวจสอบการชนกับยานพาหนะ
        self._check_vehicle_collision()
        
        # ตรวจสอบการจมน้ำ
        self._check_water_collision()
        
        # ตรวจสอบการเข้าบ้าน
        self._check_home_collision()
    
    def _check_vehicle_collision(self):
        """ตรวจสอบการชนกับยานพาหนะ"""
        frog_rect = self.frog.rect
        
        for vehicle in self.vehicles:
            if frog_rect.colliderect(vehicle.rect):
                self._lose_life()
                return
    
    def _check_water_collision(self):
        """ตรวจสอบการตกน้ำ"""
        # ตรวจสอบว่ากบอยู่ในโซนแม่น้ำหรือไม่
        if 50 < self.frog.y < 200:  # โซนแม่น้ำ
            on_safe_object = False
            self.frog.on_log = False
            
            # ตรวจสอบว่าอยู่บนขอนไม้หรือไม่
            for log in self.logs:
                if self.frog.rect.colliderect(log.rect):
                    on_safe_object = True
                    self.frog.on_log = True
                    self.frog.log_speed = log.speed
                    self.frog.update_on_log(log.speed)
                    break
            
            # ตรวจสอบว่าอยู่บนเต่าหรือไม่
            if not on_safe_object:
                for turtle in self.turtles:
                    if not turtle.is_diving and self.frog.rect.colliderect(turtle.rect):
                        on_safe_object = True
                        self.frog.on_log = True
                        self.frog.log_speed = turtle.speed
                        self.frog.update_on_log(turtle.speed)
                        break
            
            # หากไม่ได้อยู่บนวัตถุปลอดภัย = จมน้ำ
            if not on_safe_object:
                self._lose_life()
        
        else:
            # ไม่อยู่ในโซนแม่น้ำ
            self.frog.on_log = False
            self.frog.log_speed = 0
    
    def _check_home_collision(self):
        """ตรวจสอบการเข้าบ้าน"""
        if self.frog.y <= 50:  # โซนบ้าน
            home_found = False
            
            for home in self.homes:
                if self.frog.rect.colliderect(home.rect):
                    if not home.occupied:
                        home.occupied = True
                        self.game_state.homes_filled += 1
                        self.game_state.score += 100
                        
                        # ตรวจสอบว่าบ้านเต็มหรือยัง
                        if self.game_state.homes_filled >= 5:
                            self._complete_level()
                        else:
                            self._reset_frog()
                    home_found = True
                    break
            
            # หากไม่ได้เข้าบ้านแต่อยู่ในโซนบ้าน = ตาย
            if not home_found:
                self._lose_life()
    
    def _lose_life(self):
        """เสียชีวิต"""
        self.game_state.lives -= 1
        
        if self.game_state.lives <= 0:
            self.game_state.game_over = True
        else:
            self._reset_frog()
    
    def _reset_frog(self):
        """รีเซ็ตตำแหน่งกบและเวลา"""
        self.frog.reset_position()
        self.game_state.time_left = 30.0
    
    def _complete_level(self):
        """จบด่าน"""
        self.game_state.level_complete = True
        self.game_state.score += int(self.game_state.time_left) * 10  # โบนัสจากเวลาที่เหลือ
    
    def restart_game(self):
        """เริ่มเกมใหม่"""
        self.game_state = GameState()
        self._init_game_objects()
    
    def draw_game(self):
        """วาดหน้าจอเกม"""
        # ล้างหน้าจอ
        self.screen.fill(Colors.BLACK)
        
        # วาดพื้นหลัง
        self._draw_background()
        
        # วาดวัตถุต่างๆ
        if not self.game_state.game_over and not self.game_state.level_complete:
            # วาดยานพาหนะ
            for vehicle in self.vehicles:
                vehicle.draw(self.screen)
            
            # วาดขอนไม้และเต่า
            for log in self.logs:
                log.draw(self.screen)
            
            for turtle in self.turtles:
                turtle.draw(self.screen)
            
            # วาดกบ
            self.frog.draw(self.screen)
        
        # วาดบ้าน
        for home in self.homes:
            home.draw(self.screen)
        
        # วาดข้อมูลเกม
        self._draw_ui()
        
        # วาดข้อความสถานะ
        self._draw_status_messages()
        
        pygame.display.flip()
    
    def _draw_background(self):
        """วาดพื้นหลัง"""
        # โซนปลอดภัยด้านล่าง
        pygame.draw.rect(self.screen, Colors.DARK_GREEN, 
                        (0, SCREEN_HEIGHT - 80, SCREEN_WIDTH, 80))
        
        # โซนถนน
        pygame.draw.rect(self.screen, Colors.GRAY, 
                        (0, SCREEN_HEIGHT - 280, SCREEN_WIDTH, 200))
        
        # โซนปลอดภัยกลาง
        pygame.draw.rect(self.screen, Colors.DARK_GREEN, 
                        (0, 200, SCREEN_WIDTH, 80))
        
        # โซนแม่น้ำ
        pygame.draw.rect(self.screen, Colors.LIGHT_BLUE, 
                        (0, 50, SCREEN_WIDTH, 150))
        
        # โซนบ้าน
        pygame.draw.rect(self.screen, Colors.DARK_GREEN, 
                        (0, 0, SCREEN_WIDTH, 50))
    
    def _draw_ui(self):
        """วาดข้อมูล UI"""
        # คะแนน
        score_text = self.font.render(f"Score: {self.game_state.score}", True, Colors.WHITE)
        self.screen.blit(score_text, (10, SCREEN_HEIGHT - 30))
        
        # ชีวิต
        lives_text = self.font.render(f"Lives: {self.game_state.lives}", True, Colors.WHITE)
        self.screen.blit(lives_text, (200, SCREEN_HEIGHT - 30))
        
        # ระดับ
        level_text = self.font.render(f"Level: {self.game_state.level}", True, Colors.WHITE)
        self.screen.blit(level_text, (350, SCREEN_HEIGHT - 30))
        
        # เวลา
        time_text = self.font.render(f"Time: {int(self.game_state.time_left)}", True, Colors.WHITE)
        self.screen.blit(time_text, (500, SCREEN_HEIGHT - 30))
    
    def _draw_status_messages(self):
        """วาดข้อความสถานะเกม"""
        if self.game_state.game_over:
            game_over_text = self.font.render("GAME OVER", True, Colors.RED)
            restart_text = self.small_font.render("Press R to restart", True, Colors.WHITE)
            
            text_rect = game_over_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
            restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 40))
            
            self.screen.blit(game_over_text, text_rect)
            self.screen.blit(restart_text, restart_rect)
        
        elif self.game_state.level_complete:
            complete_text = self.font.render("LEVEL COMPLETE!", True, Colors.YELLOW)
            restart_text = self.small_font.render("Press R to continue", True, Colors.WHITE)
            
            text_rect = complete_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
            restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 40))
            
            self.screen.blit(complete_text, text_rect)
            self.screen.blit(restart_text, restart_rect)
    
    def run(self):
        """เรียกใช้เกมหลัก"""
        while self.running:
            result = self.handle_input()
            if result is False:  # ผู้เล่นปิดเกม
                self.running = False
                break
            
            self.update_game_logic()
            self.draw_game()
            self.clock.tick(FPS)
        
        pygame.quit()
        return self.game_state.score

def main():
    """ฟังก์ชันหลักเรียกใช้เกม"""
    game = FroggerGame()
    return game.run()

if __name__ == "__main__":
    main() คุณคือ senior python programmer ในการเขียน unit test โดยใช้ pytest สำหรับการทดสอบเกม โดยคุณมีทักษะสูงมากทั้งการเขียนโค้ด การแก้ไขข้อผิดพลาด ดังนั้นโค้ดที่คุณให้มาไม่ควรมีข้อผิดพลาด และต้องสามารถรันได้เลย งานของคุณคือการเขียน unit test โดยใช้ pytest เพื่อทำการทดสอบโค้ดเกมที่ให้ไปโดยมีข้อกำหนดในการเขียนทดสอบให้ statement coverage และ branch coverage ต้องมีค่าเท่ากับ 100% 
